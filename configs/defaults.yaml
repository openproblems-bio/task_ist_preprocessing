
# ----------------- SEGMENTATION ----------------- #

custom: 
  custom_dummy_param: None

# Parameters for watershed
# - normalize_func : Function to perform image normalization for example gamma, sigmoid
# - contrast_adjustment_func: Function to adjust/balance the contract of the image
# - blur_func: Funtion to blurr the image
# - threshold_func: Funtions to find the masking threshold for the image to apply on watershed
# - distance_transform_func: Function to perfrom distance_transform
# - local_maxima_func: Function to find local maximum as marker for watershed
# - post_processing_func: Function to perfrom image processing after segmentation
# Default parameters for pre-processing functions
# - normalize
#    - adjust_gamma(image, gamma=1, gain=1)
#    - adjust_log(image, gain=1, inv=False)
#    - adjust_sigmoid(image, cutoff=0.5, gain=10, inv=False)
# - contrast adjustment
#    - equalize_adapthist(image, kernel_size=None, clip_limit=0.01, nbins=256)
#    - equalize_hist(image, nbins=256, mask=None)
#    - rescale_intensity(image, in_range='image', out_range='dtype')
# - blur
#    - gaussian(image, sigma=1, output=None, mode='nearest', cval=0, preserve_range=False, truncate=4.0, *, channel_axis=<ChannelAxisNotSet>)
#    - median(image, footprint=None, out=None, mode='nearest', cval=0.0, behavior='ndimage')
# - threshold
#    - threshold_otsu(image=None, nbins=256, *, hist=None)
#    - threshold_triangle(image, nbins=256)
#    - rank.otsu(image, footprint, out=None, mask=None, shift_x=False, shift_y=False, shift_z=False)
# - distance transform
#    - distance_transform_edt(input, sampling=None, return_distances=True, return_indices=False, distances=None, indices=None)
# - local maxima
#    - find_local_maxima(distance_transform, min_distance=5)
# - post processing
#    - remove_small_objects(ar, min_size=64, connectivity=1, *, out=None)

watershed:
  normalize_func: "gamma"
  normalize_gamma: 1
  normalize_gain: 1
  normalize_inv: False
  normalize_cutoff: 0.5

  contrast_adjustment_func: "equalize_adapthist"
  contrast_adjustment_kernel_size: None
  contrast_adjustment_clip_limit: 0.01
  contrast_adjustment_nbins: 256
  contrast_adjustment_mask: None
  contrast_adjustment_in_range: "image"
  contrast_adjustment_out_range: "dtype"

  blur_func: "gaussian"
  blur_sigma: 1
  blur_output: None
  blur_mode: 'nearest'
  blur_cval: 0
  blur_preserve_range: False
  blur_truncate: 4.0
  blur_footprint: None   #delete?
  blur_out: None   #delete?
  blur_behavior: 'ndimage'   #delete?

  threshold_func: "local_otsu"  #"otsu","triangle"
  threshold_nbins: 256
  threshold_hist: None
  threshold_out: None
  threshold_mask: None
  threshold_shift_x: False
  threshold_shift_y: False
  threshold_shift_z: False
  threshold_footprint: "square"
  threshold_footprint_size: 50

  distance_transform_func: "distance_transform_edt"
  distance_transform_sampling: None
  distance_transform_return_distances: True
  distance_transform_return_indices: False
  distance_transform_distances: None
  distance_transform_indices: None
  
  local_maxima_func: "find_local_maxima"
  local_maxima_min_distance: 5

  post_processing_func_1: "remove_small_objects"
  post_processing_min_size_1: 64
  post_processing_connectivity_1: 1
  post_processing_out_1: None

  post_processing_func_2: "remove_small_holes"
  post_processing_area_threshold_2: 64
  post_processing_connectivity_2: 1
  post_processing_out_2: None

  bg_intensity_filter_bg_factor: 0.3 # set to 0 to disable
  bg_intensity_filter_window_size: 1000 
  bg_intensity_filter_bg_size: 2000

# Parameters for cellpose
# - Parameter used in GUI
#    - flow_threshold: Flow error threshold. Cells with errors below this threshold are retained. A higher threshold may keep more cells but some may be poorly segmented.
#    - cellprob_threshold: Pixels with value above this threshold are kept for masks. A lower threshold can find more and larger masks.
#    - stitch_threshold: If this value is more than 0.0, not do_3D, and image sizes are equal, masks are stitched in 3D to return volume segmentation. A higher threshold results in more stitching but can create larger segments.
#    - channels: A list indicating which channels to segment. None means all channels will be segmented. The number and choice of channels can affect segmentation results.
# - Detailed Parameter
#    - z_axis: Axis index for the Z (depth) dimension. None implies it will be determined automatically. Important for 3D images.
#    - normalize: If True, normalize image so that 0.0 corresponds to 1st percentile and 1.0 corresponds to 99th percentile of image intensities in each channel. This can enhance contrast and improve segmentation.
#    - invert: If True, invert image pixel intensity before running network. This can be beneficial when objects of interest are dark on a light background.
#    - rescale: Rescale factor applied if diameter is not provided. None implies it will be estimated automatically. This could affect cell size in final segmentation.
#    - diameter (pixel): Estimated cell diameter. None implies diameter will be estimated automatically. Affects the size of cells in segmentation.
#    - do_3D: If True, run 3D segmentation on 4D image input. Determines the dimensionality of the segmentation.
#    - anisotropy: Rescaling factor for 3D segmentation. None implies no rescaling. Important when Z spacing is different from X or Y spacing.
#    - net_avg: If True, runs the 4 built-in networks and averages the results. If False, runs a single network. Multiple networks may increase accuracy but take more time.
#    - augment: If True, augment the image by tiling with overlapping tiles and flipping overlapped regions. This can enhance the robustness of the segmentation but requires more computation.
#    - tile: If True, tile the image to ensure GPU/CPU memory usage is limited. Prevents out-of-memory errors.
#    - tile_overlap: Determines the fraction of overlap of tiles when computing flows. A larger overlap may improve consistency at the expense of increased computation.
#    - resample: If True, run dynamics at the original image size. May improve segmentation accuracy but be slower.
#    - interp: If True, interpolate during 2D dynamics. Not available for 3D. May improve segmentation accuracy but be slower.
#    - min_size: Minimum number of pixels per mask. A smaller value may yield more but smaller segments.
#    - progress: PyQt progress bar. None means no progress bar will be shown.
#    - loop_run: If True, continue running the loop until the model is loaded. Useful for preventing early termination.
#    - model_loaded: If True, the model is already loaded. Useful for saving loading time when repeatedly running the segmentation.

cellpose:
  batch_size: 8
  model_type: "cyto"
  #channels: None
  channel_axis: None
  z_axis: None
  normalize: True
  invert: False
  rescale: None
  diameter: 30.0  #None -> infer automatically
  do_3D: False
  anisotropy: None
  net_avg: False
  augment: False
  tile: True
  tile_overlap: 0.1
  resample: True
  interp: True
  flow_threshold: 0.4
  cellprob_threshold: 0.0
  min_size: 15  #Can turn off with -1
  stitch_threshold: 0.0 # Only for 3D data
  #rescale: None
  #progress: None
  #model_loaded: False

mesmer:
    batch_size: 8
    image_mpp: 0.2125
    compartment: "nuclear"
    squeeze: None  # TODO: should None be default? also in run_mesmer.py is the if clause actually correct?

binning:
  bin_size: 30

segmentation_params:
  expand: 0 #SCALE PARAM


# ----------------- ASSIGNMENT ----------------- #


# clustermap parameters
# - window_size: tile data into tiles of window_size and stitch at the end. (no tiling for window_size=None)
# - Model input params:
#    - xy_radius: float. Estimation of radius of cells in x-y plane.
#    - z_radius: float. Estimation of radius of cells in z axis; 0 if data is 2D. TODO
#    - gauss_blur: bool. Choose whether to apply Gaussian blur with sigma=model_sigma.
#    - sigma: float. Sigma value for Gaussian blur.
#    - fast_preprocess: bool. Binarize DAPI images with erosion and morphological reconstruction before OTSU thresholding when True. Binarize DAPI images with only OTSU thresholding when False.
# - Preprocess params:
#    - pct_filter: Controls the threshold for marking points as noise based on the percentile of the distances distribution.
#    - LOF: Use Unsupervised Outlier Detection using the LocalOutlierFactor (LOF) from sklearn.neighbors in preprocessing (Local noise rejection)
#    - contamination: LOF dependent. The amount of contamination of the data set, i.e. the proportion of outliers in the data set. When fitting this is used to define the threshold on the scores of the samples. should be in the range (0, 0.5]
# - Segmentation params:
#    - min_spot_per_cell: Erase clusters with less than this number of spots.
#    - cell_num_threshold: A threshold for deciding the number of cells using lambda curve. ρ (Density), δ (Distance), Lambda := λ=ρ⋅δ or λ=ln(ρ)⋅δ
#    - add_dapi: Whether or not to add Dapi points for (Density Peak Clustering) DPC
#    - use_genedis: Whether or not to use gene ??? for (Density Peak Clustering) DPC
# - Preprocess and Segmentation param:
#    - dapi_grid_interval: sample interval in DAPI image. A large value will consume more computation resources(!) and give more accurate results (most of the time)
## recommanded combination model_fast_preprocess = True and model_gauss_blur = False
## recommanded combination model_fast_preprocess = False and model_gauss_blur = True

clustermap:
  # tiling
  window_size: 700  # small values to keep memory usage low, too small will lead to bad segmentations though
  # model
  #use_dapi: True
  xy_radius: 40
  z_radius: 0
  fast_preprocess: False 
  gauss_blur: True
  sigma: 1
  # preprocess
  pct_filter: 0.0
  LOF: False
  contamination: 0
  # segmentation
  min_spot_per_cell: 5
  cell_num_threshold: 0.1 
  add_dapi: True
  use_genedis: True
  # preprocess & segmentation
  dapi_grid_interval: 5



pciseq:
  # list of genes to be excluded during cell-typing, e.g ['Aldoc', 'Id2'] to exclude all spots from Aldoc and Id2
  exclude_genes: None

  # Maximum number of loops allowed for the Variational Bayes to run
  max_iter: 1000

  # Convergence achieved if assignment probabilities between two successive loops is less than the tolerance
  CellCallTolerance: 0.02

  # A gamma distribution expresses the efficiency of the in-situ sequencing for each gene. It tries to capture
  # the ratio of the observed over the theoretical counts for a given gene. rGene controls the variance and
  # Inefficiency is the average of this assumed Gamma distribution
  rGene: 20
  Inefficiency: 0.2

  # If a spot is inside the cell boundaries this bonus will give the likelihood an extra boost
  # in order to make the spot more probable to get assigned to the cell than another spot positioned
  # outside the cell boundaries
  InsideCellBonus: 2

  # To account for spots far from the some a uniform distribution is introduced to describe those misreads.
  # By default this uniform distribution has a density of 1e-5 misreads per pixel.
  MisreadDensity: 0.00001

  # Gene detection might come with irregularities due to technical errors. A small value is introduced
  # here to account for these errors. It is an additive factor, applied to the single cell expression
  # counts when the mean counts per class and per gene are calculated.
  SpotReg: 0.1

  # By default only the 3 nearest cells will be considered as possible parent cells for any given spot.
  # There is also one extra 'super-neighbor', which is always a neighbor to the spots so we can assign
  # the misreads to. Could be seen as the background. Hence, by default the algorithm tries examines
  # whether any of the 3 nearest cells is a possible parent cell to a given cell or whether the spot is
  # a misread
  nNeighbors: 3

  # A gamma distributed variate from Gamma(rSpot, 1) is applied to the mean expression, hence the counts
  # are distributed according to a Negative Binomial distribution.
  # The value for rSpot will control the variance/dispersion of the counts
  rSpot: 2

  # Boolean, if True the output will be saved as tsv files in a folder named 'pciSeq' in your system's temp dir.
  save_data: False

  # output directory 'default' will save to temp location
  output_path: ['default']

  # Use either np.float16 or np.float32 to reduce memory usage. In most cases RAM consumption shouldnt
  # need more than 32Gb RAM. If you have a dataset from a full coronal mouse slice with a high number of
  # segmented cells (around 150,000) a gene panel of more than 250 genes and 100 or more different
  # cell types (aka clusters, aka classes) in the single cell data then you might need at least 64GB on
  # your machine. Changing the datatype to a float16 or float32 will help keeping RAM usage to a lower
  # level
  dtype: np.float64

baysor:
  use_3d : True
  # Taken from https://github.com/kharchenkolab/Baysor/blob/master/configs/example_config.toml
  
  # [Data]
  # Name of the x column in the input data. Default: "x"
  x : '"x"'
  # Name of the y column in the input data. Default: "y"
  y : '"y"'
  # Name of the z column in the input data. Default: "z"
  z : '"z"'
  # Name of gene column in the input data. Default: "gene"
  gene : '"Gene"'
  # Minimal number of molecules per gene. Default: 1
  min_molecules_per_gene : 1
  # Minimal number of molecules for a cell to be considered as real. It's an important parameter, as it's used to infer several other parameters. Default: 3
  min_molecules_per_cell : 3
  # Scale parameter, which suggest approximate cell radius for the algorithm. This parameter is required.
  scale : 50 #SCALE PARAM # if prior segmentation is provided SET TO 0 (then scale is neglected and chosen automatically)
  # Standard deviation of scale across cells. Can be either number, which means absolute value of the std, or string ended with "%" to set it relative to scale. Default: "25%"
  # "scale-std" : '"25%"',
  
  # Not exactly sure if this one should be in [Data], therefore we don't provide it via the toml, so not possibl issues here.
  prior-segmentation-confidence : 0.2
  
  # # Use scale estimate from DAPI if provided. Default: true
  # "estimate-scale-from-centers" : "true",
  # # Minimal number of molecules in a segmented region, required for this region to be considered as a possible cell. Default: min-molecules-per-cell / 4
  # # "min-molecules-per-segment" : 2, # TODO: throws Error ErrorException("Unexpected value in the config: 'min-molecules-per-segment'")
  # 
  # #[Sampling] These parameters shouldn't normally be changed
  # # Prior weight of assignment a molecule to new component. Default: 0.2
  # "new-component-weight" : 0.2,
  # # Fraction of distributions, sampled at each stage. Default: 0.3
  # "new-component-fraction" : 0.3,
  
  #[Plotting]
  # Number of neighbors (i.e. 'k' in k-NN), which is used for gene composition visualization. Larger numbers leads to more global patterns. Default: estimate from min-molecules-per-cell
  # "gene-composition-neigborhood" : 20, # TODO: ErrorException("Unexpected value in the config: 'gene-composition-neigborhood'")
  # Number of pixels per cell of minimal size, used to estimate size of the final plot. For most protocols values around 7-30 give enough visualization quality. Default: 15
  # "min-pixels-per-cell" : 15, # TODO: didn't check this one, plotting is not so important i guess
  
basic:
  basic_dummy_param: 0

# ----------------- NORMALIZATION ----------------- #


#other params?
area:
  alpha: 0
  use_max_area: True

total:
  find_area: False
  use_max_area: True

normalize_params:
  max_area: None
  min_area: None
  min_counts: 10
  min_cell_percentage: 0.8

# ----------------- ANNOTATION ----------------- #
majority:
  threshold: 0.7

ssam:
  um_per_pixel: 0.2125
  threshold: 0.7

pciseqct:
  threshold: 0.7

tangram:
  sc_ct_labels : "celltype" #Labels of the cell_type layer in the single cell adata
  device : "cpu"
  mode : "cells" # Tangram mapping mode. 'cells', 'clusters', 'constrained'. Default is 'cells'
  num_epochs : 1000 #Number of epochs. Default is 1000
  cell_id: "cell_id" #cell id column name in spatial data

mfishtools:
  qprob: 0.9     # Parameter for scaling mFISH to FACS
  thresh: -3       # Set counts less than or equal to thresh to 0
  binarize: False   # Should the data be binarized?
  cell_type_col: "celltype" # name of the cell type column in single cell data obs
  #column names in obs of spatial data
  area_col: "area"
  x_col: "centroid_x"
  y_col: "centroid_y"
  cell_id: "cell_id"

frmatch:
  #Filtering out small/poor-quality/no-marker clusters
  filter_size: 5 #filter based on the number of cells per cluster
  filter_fscore: null #NULL: do not filter based on the F-beta score, otherwise specify a numeric value between 0 and 1
  filter_nomarker: False #filter based on the boolean variable indicating if to filter reference clusters with no marker genes available in query in the case of feature_selection="reference.markers"
  add_pseudo_marker: False # Adding pseudo marker to stabilize no expression clusters in the marker gene feature space
  pseudo_expr: 1 #Pseudo marker expression values are drawn from uniform distribution from 0 to pseudo_expr
  #Numeric variables for iterative subsampling size, number of iterations, and random seed for iterations
  subsamp_size: 10
  subsamp_iter: 2000
  subsamp_seed: 1 
  numCores: 8 #null #Number of cores for parallel computing. if NULL, use the maximum number of cores detected by \code{\link[parallel]{detectCores}}. Otherwise, specify by an integer value.
  leiden_res: 1 # resolution for leiden clustering
  n_pcs: 20 # number of principal components for clustering
  cell_type_column: "celltype" # name of the cell type column in single cell data
  cell_id: "cell_id" #cell id column name in spatial data

scrattchmapping:
  cell_type_col: "celltype" # name of the cell type column in single cell data
  method: "correlation" # mapping method correlation, seurat or tree
  cell_id: "cell_id" #cell id column name in spatial data

mapmycells:
  cell_type_column: "celltype" # name of the cell type column in single cell data

nwconsensus:
  methods: "frmatch-mfishtools-scrattchmapping-ssam-tangram" # methods to include for consensus annotations
  # Method must be included alphabetically. Theoretically the same method can be included multiple times (e.g. with 
  # different ids)
  ids: "0-0-0-0-0" # Provide ids of specific parameter configurations of the other runs. This parameter only makes 
  # sense to add after a pre run of the individual methods. E.g.: "3-1-4" for methods="frmatch-ssam-tangram" would 
  # mean frmatch-3, ssam-1 etc. When only running with default values for each method, then "0-0-0" is a good choice. 
  # Note that the consensus methods can only be run if there are runs defined in the config for individual methods that 
  # generate according ids, i.e. frmatch-3 etc.
  # Note: this parameter can lead to reproducibility issues: The pipeline is constructed such that the id codes of
  # parameter combinations can be different when the config was built step after step vs being complete from the start.

gmconsensus:
  methods: "frmatch-mfishtools-scrattchmapping-ssam-tangram"
  ids: "0-0-0-0-0"
  
annotation_params:
  per_gene_correction: False
  per_gene_layer: lognorm


# ----------------- METRICS ----------------- #
metrics:
  chunk_size: 10